<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles/dashboard.css">
    <link rel="icon" href="https://i.ibb.co/XCjDk5m/placeholder.png">
    <title>Road Closures</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .submit-button {
            background-color: #4CAF50;
            color: white;
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }

        .submit-button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="regStoreCon1">
            <form id="roadClosure" onsubmit="submitRoadClosure(event)">
                <label class="label" for="reporterName">Reporter's Name</label>
                <input class="input" type="text" id="reporterName" required><br>

                <label class="label" for="roadAddress">Starting Point</label>
                <div class="addressCon">
                    <input class="input" type="text" id="roadAddress" required>
                    <button type="button" class="locationButton" onclick="useCurrentLocation2()">Use My Location</button>
                </div>
                <label class="label" for="roadAddress2">Ending Point</label>
                <div class="addressCon">
                <input class="input" type="text" id="roadAddress2" required>
                <button type="button" class="locationButton" onclick="useCurrentLocation3()">Use My Location</button>
                </div>
                <ul id="suggestions"></ul>

                <div class="regStoreSubCon2">
                    <fieldset class="supply">
                        <legend>Reason for Closure:</legend>
                        <label><input type="radio" name="roadReason" value="Vehicular Accident"> Vehicular Accident</label><br>
                        <label><input type="radio" name="roadReason" value="Landslide/Rock Slide"> Landslide/Rock Slide</label><br>
                        <label><input type="radio" name="roadReason" value="Road Maintenance"> Road Maintenance</label><br>
                        <label><input type="radio" name="roadReason" value="Electrical Repair"> Electrical Repair</label><br>
                        <label><input type="radio" name="roadReason" value="Flooding"> Flooding</label><br>
                    </fieldset><br>
                </div>
                <div class="centerDiv">
                <button type="submit" class="submitButton">Submit Report</button>
            </div>
            </form>
        </div>

        <div class="MapContainerBig" id="mapContainer"></div>
    </div>
    <script src="/dashboard.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', () => {
    // Initialize the map
    const map = L.map('mapContainer').setView([13.7565, 121.0583], 13); // Centered on the Philippines

    // Add OpenStreetMap tiles
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: 'Â© OpenStreetMap contributors'
    }).addTo(map);

    // Marker state
    let startMarker = null;
    let endMarker = null;
    let roadLine = null; // To hold the red line

    // Input fields
    const roadAddress1 = document.getElementById('roadAddress');
    const roadAddress2 = document.getElementById('roadAddress2');

    // Fetch address asynchronously from coordinates
    const getAddressFromCoords = async (lat, lng) => {
        const url = `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json`;
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error('Failed to fetch address');
            const data = await response.json();
            return data.display_name || `${lat}, ${lng}`;
        } catch (error) {
            console.error('Error fetching address:', error);
            return `${lat}, ${lng}`; // Fallback to coordinates
        }
    };

    // Function to handle marker placement and update input fields
    const placeMarker = async (lat, lng, type) => {
        const address = await getAddressFromCoords(lat, lng);
        if (type === 'start') {
            // Place or update the starting point marker
            if (startMarker) {
                startMarker.setLatLng([lat, lng]);
            } else {
                startMarker = L.marker([lat, lng], { draggable: true }).addTo(map);

                // Add dragend event to update address when marker is moved
                startMarker.on('dragend', async () => {
                    const newPos = startMarker.getLatLng();
                    roadAddress1.value = await getAddressFromCoords(newPos.lat, newPos.lng);
                    updateRoadLine(); // Re-draw line after marker move
                });
            }
            roadAddress1.value = address;
            map.setView([lat, lng], 13); // Focus on the start marker
        } else if (type === 'end') {
            // Place or update the ending point marker
            if (endMarker) {
                endMarker.setLatLng([lat, lng]);
            } else {
                endMarker = L.marker([lat, lng], { draggable: true }).addTo(map);

                // Add dragend event to update address when marker is moved
                endMarker.on('dragend', async () => {
                    const newPos = endMarker.getLatLng();
                    roadAddress2.value = await getAddressFromCoords(newPos.lat, newPos.lng);
                    updateRoadLine(); // Re-draw line after marker move
                });
            }
            roadAddress2.value = address;
            map.setView([lat, lng], 13); // Focus on the end marker
        }

        // After both markers are placed, draw the line
        if (startMarker && endMarker) {
            updateRoadLine();
        }
    };

    // Function to draw or update the red line between the markers
    const updateRoadLine = () => {
        if (startMarker && endMarker) {
            const latLngs = [startMarker.getLatLng(), endMarker.getLatLng()];

            // If the line already exists, update its position
            if (roadLine) {
                roadLine.setLatLngs(latLngs);
            } else {
                // Draw a new red line
                roadLine = L.polyline(latLngs, { color: 'red', weight: 5 }).addTo(map);

                // Add a popup with a "Road Closed" message
                roadLine.bindPopup('Road Closed').openPopup();
            }
        }
    };

    // Map click event to add markers
    map.on('click', async (event) => {
        const { lat, lng } = event.latlng;

        if (!startMarker) {
            await placeMarker(lat, lng, 'start');
        } else if (!endMarker) {
            await placeMarker(lat, lng, 'end');
        } else {
            alert('Both starting and ending points are already set. Drag them to adjust.');
        }
    });

    // Use current location for the starting point
    window.useCurrentLocation2 = () => {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(async (position) => {
                const { latitude, longitude } = position.coords;
                await placeMarker(latitude, longitude, 'start');
            }, (error) => {
                console.error('Error getting location:', error);
                alert('Unable to retrieve your location.');
            });
        } else {
            alert('Geolocation is not supported by this browser.');
        }
    };

    // Use current location for the ending point
    window.useCurrentLocation3 = () => {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(async (position) => {
                const { latitude, longitude } = position.coords;
                await placeMarker(latitude, longitude, 'end');
            }, (error) => {
                console.error('Error getting location:', error);
                alert('Unable to retrieve your location.');
            });
        } else {
            alert('Geolocation is not supported by this browser.');
        }
    };

    // Clear markers, line, and inputs
    window.clearMarkers = () => {
        if (startMarker) map.removeLayer(startMarker);
        if (endMarker) map.removeLayer(endMarker);
        if (roadLine) map.removeLayer(roadLine);
        startMarker = endMarker = roadLine = null;
        roadAddress1.value = '';
        roadAddress2.value = '';
    };

    // Handle form submission
    const roadClosureForm = document.getElementById('roadClosure');
    roadClosureForm.addEventListener('submit', (event) => {
        event.preventDefault();

        const startLatLng = startMarker.getLatLng();
        const endLatLng = endMarker.getLatLng();

        alert(`Road closure submitted from:
            Starting Point: ${roadAddress1.value} (${startLatLng.lat}, ${startLatLng.lng})
            Ending Point: ${roadAddress2.value} (${endLatLng.lat}, ${endLatLng.lng})`);
        
        // Submit road closure logic
        // Include roadAddress1.value and roadAddress2.value in the API payload
    });
});


</script>
</body>
</html>
